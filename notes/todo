
High Priority
=============
Fix list comprehensions (variables are undefined)
Fix recursion
Use a code coverage tool to make sure everything is covered by tests
Support calling functions that are defined later (needed for mutual recursion)
Return Any type from builtin functions that are not determinate

Imports
=======
Support import from and aliases
Support heirarchical module names in import

Classes
=======
Handle attribute assignment
Handle attribute assignment when it is one item of a tuple assignment
Process self.x into object namespace
- When you reach a FunctionDef for __init__
    set first param to type "Object[<Class>]"
    need some way to know which Class we are in
- When you reach an assignment for an attribute
    if you are in an __init__ body and the left side is the first arg
    then allow subnamespace assignment without warnings
- After processing FunctionDef for __init__
    look for the symbol for "self" (whatever the first parameter is)
    and copy its subnamespace to the current namespace (along with __init__)
- In the ClassDef, after processing the class namespace,
    add two types: "Object[<Class>]" with subnamespace equal to
    the namespace from the ClassDef and a function "<Class>" with
    return type "Object[<Class>]" and arguments from the __init__ function
Check that __init__ takes at least one argument

Medium Priority
===============
Check that function return values are not discarded
Unwrap maybe in if-else branches
Unwrap maybe in comprehensions with "if x is not None" conditions

Low Priority
============
Implement visit_Delete and actually remove items from scope
Cache results of imports for speed (/var/cache/...)
Optimize function return type evaluation when return type can be determined
    while processing the definition
Warn when function is never called if it starts with an underscore

Limitations
===========
Custom operator overloading with things like __getitem__ or __add__ don't work
Tuple indices must be literal numbers
    - could cheat if all types in the tuple are the same
